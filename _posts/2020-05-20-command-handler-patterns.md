---
title: Command and command handler patterns
permalink: /:title:output_ext
layout: post
modal-id: 1
date: 2020-05-17
image: command-handler.svg
alt: Command and command handler patterns
---

# Command and CommandHandler patterns

A command is an object (often Data Transfer Object) used to encapsulate all information needed to achieve an action. We will use this pattern to represent user intents and we will give them to Command Handlers. A command handler is just a callable which will perform every action to complete the user intent.

![Image of Yaktocat](assets/img/posts/command-handler.svg)

There are two important rules to know. The first one: the command handler can only handle one command because a use case cannot be handled several ways. The second one: the command handler should receive a valid command because the only responsibility of a command handler is to handle use cases.

Let’s take a simple example: an account creation. Our business expert only expects that users need to provide an email and a password to create an account. Users will be able to change their username when they want.

First, we need to create a command named CreateAnAccount which will represent the user intent:

```php
final class CreateAnAccount
{
   public string $accountIdentifier;
   public string $username;
   public string $password;
}
```

The command has three properties: `email` and `password` given by the user and the last one `accountIdentifier` generated by the application. We cannot use the username property as an identifier because it is mutable. The command is not really an object because it does not have any behavior but only a state. This is what we call a DTO (Data Transfer Object) and its only purpose is to encapsulate data and carry them until the command handler.

Then we need to create a command handler to handle this use case. It is callable, in our example, an invokable object. Its method should receive the valid command and it should return nothing. With the command data we execute all actions needed to handle the use case.

```php
final class CreateAnAccountHandler
{
   private Accounts $accounts;

   public function __construct(Accounts $accounts)
   {
       $this->accounts = $accounts;
   }

   public function __invoke(CreateAnAccount $createAnAccount): void
   {
       $account = Account::create(
           $createAnAccount->accountIdentifier,
           $createAnAccount->username,
           $createAnAccount->password
       );

       $this->accounts->add($account);
   }
}
```

## Why are command properties public?

The properties are public because it eases the command creation thanks to libraries like Symfony Serializer component or Symfony Form component. They are able to easily map json or form data to an object which have the same properties. 

```php
 // Symfony serializer component
$createAccount = $this->serializer->deserialize(
      $request->getContent(),
      CreateAnAccount::class,
      'json'
);

 // Symfony form component
$form = $this->createForm(AccountType::class, new CreateAnAccount());
$form->handleRequest($request);
```

## Can we build a command through a constructor?

Yes for sure, if you don’t use any third libraries which need public properties please make your commands immutables. 

I’m used to adding a constructor even though my commands have public properties because it eases their creation for my acceptance tests because I don’t use the Symfony serializer. I don’t need to instantiate the command and then set every property manually.

**Caution:** If you use the Serializer or the Form component all constructor parameters must be optionals because those libraries need to create it without giving any parameters.

## How to validate a command?

After the command creation, I use the Symfony validator to validate them but you are free to use your favorite library. If you are using a command bus don’t hesitate to create a middleware which automatically enables data validation. This feature is provided by Symfony messenger for instance.


